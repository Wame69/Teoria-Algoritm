using System;

class CheckersGame
{
    static char[,] board = new char[8, 8];
    static char currentPlayer = 'w'; 
    static bool multipleCapture = false;
    static bool mustCapture = false;

    static void Main(string[] args)
    {
        InitializeBoard();
        DrawBoard();

        while (true)
        {
            Console.WriteLine($"{(currentPlayer == 'w' ? "Белые" : "Черные")} ходят.");

            mustCapture = CheckCaptureAvailability(currentPlayer);

            if (mustCapture)
            {
                Console.WriteLine("У вас есть возможность рубить. Если вы не рубите, шашка сгорит.");
            }

            Console.Write("Введите 'сдаться', чтобы завершить игру, или начальную позицию (x y): ");
            string input = Console.ReadLine();
            if (input.ToLower() == "сдаться")
            {
                Console.WriteLine($"{(currentPlayer == 'w' ? "Белые" : "Черные")} сдались. Игра окончена.");
                break;
            }

            string[] startInput = input.Split();
            int startX = int.Parse(startInput[0]);
            int startY = int.Parse(startInput[1]);

            Console.Write("Введите конечную позицию (x y): ");
            string[] endInput = Console.ReadLine().Split();
            int endX = int.Parse(endInput[0]);
            int endY = int.Parse(endInput[1]);

            if (IsValidMove(startX, startY, endX, endY))
            {
                MakeMove(startX, startY, endX, endY);
                DrawBoard();

                if (multipleCapture)
                {
                    while (CanCapture(endX, endY))
                    {
                        Console.WriteLine("Вы можете продолжить рубить. Сделайте следующий ход.");
                        Console.Write("Введите конечную позицию (x y) для следующего взятия: ");
                        endInput = Console.ReadLine().Split();
                        int nextX = int.Parse(endInput[0]);
                        int nextY = int.Parse(endInput[1]);

                        if (IsValidMove(endX, endY, nextX, nextY))
                        {
                            MakeMove(endX, endY, nextX, nextY);
                            DrawBoard();
                            endX = nextX;
                            endY = nextY;
                        }
                        else
                        {
                            Console.WriteLine("Неверный ход. Попробуйте снова.");
                        }
                    }
                    multipleCapture = false;
                }

                if (mustCapture && !CanCapture(startX, startY))
                {
                    Console.WriteLine("Вы не сделали обязательное взятие. Ваша шашка сгорела.");
                    board[startY, startX] = ' ';
                }

                currentPlayer = currentPlayer == 'w' ? 'b' : 'w'; 
            }
            else
            {
                Console.WriteLine("Неверный ход. Попробуйте снова.");
            }
        }
    }

    static void InitializeBoard()
    {
        for (int y = 0; y < 8; y++)
        {
            for (int x = 0; x < 8; x++)
            {
                if ((x + y) % 2 == 1)
                {
                    if (y < 3) board[y, x] = 'b'; 
                    else if (y > 4) board[y, x] = 'w'; 
                    else board[y, x] = ' '; 
                }
                else
                {
                    board[y, x] = ' '; 
                }
            }
        }
    }

    static void DrawBoard()
    {
        Console.WriteLine("   0   1   2   3   4   5   6   7 ");
        Console.WriteLine("  +---+---+---+---+---+---+---+---+");
        for (int y = 0; y < 8; y++)
        {
            Console.Write($"{y} |");
            for (int x = 0; x < 8; x++)
            {
                Console.Write($" {board[y, x]} |");
            }
            Console.WriteLine();
            Console.WriteLine("  +---+---+---+---+---+---+---+---+");
        }
    }

    static bool IsValidMove(int startX, int startY, int endX, int endY)
    {
        if (!IsInsideBoard(startX, startY) || !IsInsideBoard(endX, endY)) return false;
        if (board[startY, startX] == ' ') return false; 
        if (board[endY, endX] != ' ') return false; 

        char piece = board[startY, startX];
        if ((currentPlayer == 'w' && (piece == 'b' || piece == 'B')) ||
            (currentPlayer == 'b' && (piece == 'w' || piece == 'W')))
        {
            return false; 
        }

        int deltaX = Math.Abs(endX - startX);
        int deltaY = Math.Abs(endY - startY);

        if (deltaX == 1 && deltaY == 1 && !multipleCapture)
        {
            return true;
        }

        if (deltaX == 2 && deltaY == 2)
        {
            int midX = (startX + endX) / 2;
            int midY = (startY + endY) / 2;
            if (IsEnemyPiece(midX, midY, currentPlayer))
            {
                multipleCapture = true;
                return true;
            }
        }


        if (char.IsUpper(piece) && deltaX == deltaY)
        {
            int dirX = Math.Sign(endX - startX);
            int dirY = Math.Sign(endY - startY);
            bool foundEnemy = false;

            int x = startX + dirX;
            int y = startY + dirY;
            while (x != endX && y != endY)
            {
                if (board[y, x] != ' ')
                {
                    if (IsEnemyPiece(x, y, currentPlayer) && !foundEnemy)
                    {
                        foundEnemy = true;
                    }
                    else
                    {
                        return false;
                    }
                }
                x += dirX;
                y += dirY;
            }

            if (foundEnemy)
            {
                multipleCapture = true;
            }
            return foundEnemy;
        }

        return false;
    }

   
    static bool CheckCaptureAvailability(char player)
    {
        for (int y = 0; y < 8; y++)
        {
            for (int x = 0; x < 8; x++)
            {
                if (board[y, x] == player || board[y, x] == char.ToUpper(player))
                {
                    if (CanCapture(x, y)) return true;
                }
            }
        }
        return false;
    }


    static bool CanCapture(int startX, int startY)
    {
        char piece = board[startY, startX];
        bool isKing = char.IsUpper(piece);

        int[] dx = { -2, -2, 2, 2 };
        int[] dy = { -2, 2, -2, 2 };

        for (int i = 0; i < 4; i++)
        {
            int newX = startX + dx[i];
            int newY = startY + dy[i];

            if (IsInsideBoard(newX, newY) &&
                IsEnemyPiece((startX + newX) / 2, (startY + newY) / 2, currentPlayer) &&
                board[newY, newX] == ' ')
            {
                return true;
            }


            if (isKing)
            {
                int stepX = dx[i] / 2;
                int stepY = dy[i] / 2;
                int currentX = startX + stepX;
                int currentY = startY + stepY;

                while (IsInsideBoard(currentX, currentY) && board[currentY, currentX] == ' ')
                {
                    if (IsEnemyPiece(currentX + stepX, currentY + stepY, currentPlayer))
                    {
                        return true;
                    }

                    currentX += stepX;
                    currentY += stepY;
                }
            }
        }

        return false;
    }


    static bool IsEnemyPiece(int x, int y, char player)
    {
        if (!IsInsideBoard(x, y)) return false;
        char target = board[y, x];
        return (player == 'w' && (target == 'b' || target == 'B')) ||
               (player == 'b' && (target == 'w' || target == 'W'));
    }

    static bool IsInsideBoard(int x, int y)
    {
        return x >= 0 && x < 8 && y >= 0 && y < 8;
    }


    static void MakeMove(int startX, int startY, int endX, int endY)
    {
        char piece = board[startY, startX];

        if (Math.Abs(endX - startX) >= 2 && Math.Abs(endY - startY) >= 2)
        {
            int midX = (startX + endX) / 2;
            int midY = (startY + endY) / 2;

            board[midY, midX] = ' ';
        }

        board[endY, endX] = board[startY, startX];
        board[startY, startX] = ' ';

        if (endY == 0 && piece == 'w') board[endY, endX] = 'W';
        if (endY == 7 && piece == 'b') board[endY, endX] = 'B';
    }
}
